<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="js/peerjs.min.js"></script>
    <!-- <script src="js/fn.js"></script> -->
    <!--script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script-->
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
    <!-- Host Setting -->
    <div id="liveSetting">
        <div class="box" style="margin-top: 10px;">
            <button onclick="peer.disconnect()">Lock the room(can not restore!)</button>
            <button onclick="peer.reconnect()">reconnect with original Id</button>
        </div>
        <div class="box" style="margin-top: 10px;"></div>
        <div class="box" style="margin-top: 10px;"></div>
        <button id="closeLiveMenuopenRoomInfo" class="actionButton" onclick="showLive()">Close</button>
    </div>
    <!-- Detail of Room -->
    <div id="openRoomInfo">
        <div id="nodeInfo">
            <div id="stable">
                <button id="hostBlock" onclick="echoNodesMap(nodesMap, 0, nodesMap[4])">Host Node</button>
                <button id="refreshMap" onclick="echoNodesMap(nodesMap, 0, undefined)">Refresh</button>
            </div>
            <div id="block0"></div>
            <div id="block1"></div>
        </div>
        <button id="closeInfo" class="actionButton" onclick="openRoomInfo()">Close</button>
    </div>
    
    <!-- Stream Source -->
    <div id="streamSource">
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Share PC Desktop:<br />
                <button type="button" id="browserDisplayMedia" onclick="useDisplayMedia()">Use Display Stream</button>
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Share Local Devices(PE, PC...):
                <button type="button" id="browserNavigatorMediaDevices" onclick="askNavigatorMediaDevices()">Upload Local Device</button><br />
                <input type="checkbox" id="ifUseCamera">Camera
                <input type="checkbox" id="ifUseMicrophone">Microphone
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Lend Media Stream From Others
                <input id="lendAimId" type="text" placeholder="input ID OF AIM here...">
                <button type="button" id="lendStream" onclick="tryConnect(1, document.getElementById('lendAimId').value, false, true)">lend aim stream( need be accepted )</button>    
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                <input type="checkbox" id="ifNotDisplayLocalStream">If Display the localStream <br />
                —— enable for saving performance of devices
            </div>
        </div>
    
        <button id="streamSourceMenuClose" class="actionButton" onclick="streamSourceMenu()">Close</button>
    </div>

    <!-- Id interaction -->
    <div class="container">
        <div class="box">
            <button id="refreshButton" onclick="refreshMedia()">Refresh</button>
            <button type="button" id="chooseStreamSource" onclick="streamSourceMenu()">Stream Source</button>
            <button id="openRoomInfoButton" onclick="openRoomInfo()">Room Info</button>
            <button type="button" id="roomSetting" onclick="showLive()">Room Setting</button><br />
            <input type="text" id="peerId" placeholder="Input counterpart's Id" autofocus="true">
            <button id="connectButton">Connect</button>
            <div id="myid" style="font-weight: bold;">Connecting to PeerServer...</div><br />
        </div>
        <div class="box">
            <button onclick="fullWebVideo()">Full Web Video</button><br />
            <button onclick="echoHistoricalConnectedId()">console.log( HistoricalConnectedId )</button><br />
            <input type="checkbox" id="ifAutoReconnect" checked="checked">Automatic Reconnection
            <div id="status" style="font-weight: bold;">Status: Waiting to Connecting to PeerServer...</div>
        </div>
        <div class="custome">
            <div>Custome Name<input type="text" id="name" placeholder="Input your name here..." /></div>
            <div id="sumOfRoom">Audiences: 0</div><br />
            <br /><input type="checkbox" id="ifAutoClean">Auto-clean Msgs[max to 100]<br />
        </div>
    </div>
    
    <!-- Live interaction-->
    <div class="videoBox">
    <!--PS: if no video(maybe leaded by autoplay), try to click it to play(or F12 check the stream)-->
    <video id="RemoteVideo" width="100%" height="100%" controls autoplay></video></div>
    <!-- Message box -->
    <div class="chatContainer">
        <div id="chatBox" onmouseover = "autoScrollStop()" onmouseout="autoScroll()"></div>
        <div class="sendInput">
            <!-- Send box -->
            <input type="text" id="sendMessageBox" placeholder="Input message here..." autofocus="true" />
            <button type="button" id="sendButton" onclick="sendMsg()">Send</button>
            <input id="msgImgInput" type="file" onchange="msgImgBase64 = imgTransformer(this)"><br />
        </div>
    </div>

    <!-- 2.3 Local video debug>
    <h2>Local Video</h2>
    <video id="localVideo" autoplay></video-->
    <!--if you want to check the availability of localStream, here are <2.3localvideo>, desplayLocalStream(), -->
    
    <script>
        const peer = new Peer({ debug: 2})      //use PeerJS official server
        let roomIds = new Array();
        let bridge = null;
        let guest = null;
        let guests = new Array();
        let temporaryChosedNodes = new Array();
        let liveCoverBase64 = null;
        let msgImgBase64 = null;
        let fullWebVideoTimes = 0;
        let openInfoTimes = 0;
        let openLiveTimes = 0;
        let ifIndex = false;
        let lastAimId = null;
        let layers = [0];
        let mediaOpen = null;
        let parent = null;
        let ifAutoScroll = true;
        let ifConnectedAim = false;
        let remoteStream = null;
        let localStream = null;
        let deliverId = null;
        let audiences = new Array();
        let audienceIds = new Array();
        let conn = null;
        let conns = new Array();
        let connIds = new Array();
        let nodesMap = new Array();
        let hereNode = new Array();
        let changingParentConnection = false;
        let ifHitAim = false;
        let lastLayerNumber = null;
        let awaitedNodeId = null;
        let connectHistroy = [];
        const MyName = document.getElementById("name");
        const WebVideo = document.getElementById('RemoteVideo');

        // the function of getting local stream(It can't work on most of mobile phone)
        // Please note! In order for the getDisplayMedia() method to work properly, you need to use the HTTPS protocol or run it on localconn in a local development environment.
        // Otherwise, the browser may restrict access to the camera and microphone.
        // function getLocalStream() {
        //     return navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        // }

        // Listen for the event when a Peer connection is successfully opened
        // *Explanation: The provided code snippet is using the Peer.js library to establish a Peer connection. The peer.on('open', ...) code block is listening for the 'open' event, which is triggered when the Peer connection is successfully opened.
        peer.on('open', (id) => {
            hereNode = [ 1, 0, 0, [], id, getMyName(), []];
            console.log(id);
            document.getElementById("myid").innerHTML = "Your Id:<br/>" + id;
            document.getElementById("status").innerHTML="Status: Connecting to Live Room...";
        });

        // Click event for the send message button && root uploads, host receives the reply from the receiving party.
        // *Explanation: In the given code snippet, there is an event listener attached to the "connectButton" element, which triggers a function when the button is clicked.
        // *Inside the function, the "root" variable is assigned the value of the connection made with the peer using the peer Id obtained from the input field with the Id "peerId".
        document.getElementById('connectButton').addEventListener('click', () => {
            document.getElementById("status").innerHTML="Status: Connecting to Aim Node...";
            
            if (document.getElementById("peerId").value){
                connectHistroy.push(document.getElementById("peerId").value);
                // avoid connecting to someone in room and leading to the cycle.
                switch(nodesMap[0]){
                    case 1:
                        if(nodesMap[3].includes(connectHistroy.slice(-1)[0])){
                            tryConnect(3, connectHistroy.slice(-1)[0], false);
                            break;
                        }
                    default :
                        tryConnect(0, connectHistroy.slice(-1)[0], false);
                }
            }
            
        });

        function echoHistoricalConnectedId(){
            console.log(connectHistroy);
        }

        // When a new connection request is received, this code creates a data channel and sends the local or remote stream (if available) and text messages.
        peer.on('connection', (connPort) => {
            connIds.push(connPort.peer);
            conns.push(connPort);
            conn = connPort;

            // Receive the text: Host <-- Parent
            conn.on('data', (data) => {
                // data[0]:
                //  0: msg
                //  1: nodeInfo or indexRoomInfo 
                //  2: roomInfoModfied
                //  3: for reconnect: Remind the child node to replace the parent node
                //  4: for refresh: apply to the new media Stream for daliver to child
                switch (data[0]) {
                    case 0:
                        console.log('Received data:', data);
                        deliverId = data[1];
                        data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                        
                        // if ( liveSend(data) > 0 ) {
                        //     console.log("Msg delivered successfully: " + data);
                        // }else{console.log('Msg delivered failed');}

                        liveSend(data);
                        
                        appearMsg(data);
                        break;
                    case 1:
                        if ( ! audienceIds.includes(data[4])){
                            let aimPosition = connIds.indexOf(data[4]);
                            audienceIds.push(connIds[aimPosition]);
                            audiences.push(conns[aimPosition]);

                            console.log("Msg Connected to: " + data[4]);

                            if(remoteStream){      // speed debug todo
                                peer.call(data[4], remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                                console.log("Media delivered successfully: "+ data[4]);
                            }else if(localStream){
                                peer.call(data[4], localStream);
                                console.log("Media sent successfully: "+ data[4]);
                                // If you want to receive the reply of the stream
                                // usage: var temp peer.call(conn.peer, localStream);
                                // temp.on('stream', (stream) = displayStream);
                                // PS:
                                // It can only receive the previous one, so you need to deliver a new stream. 
                            }
                        }
                        recorder(data);
                        break;
                    case 2:
                        if(data[1] && confirm(data[2]+"("+ data[1] +") ask for your media stream")){
                            if(localStream){
                                peer.call(data[1], localStream);
                            } else if(remoteStream){
                                peer.call(data[1], remoteStream);
                            } else {
                                document.getElementById('streamSourceMenuClose').innerHTML="Submit";
                                streamSourceMenu();
                                document.getElementById('streamSourceMenuClose').addEventListener('click', () => {
                                    peer.call(data[1], localStream);
                                    document.getElementById('streamSourceMenuClose').innerHTML="Close";
                                
                                });
                            }
                        }
                        break;
                    case 4:
                        if(remoteStream){
                            peer.call(awaitedNodeId, remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                            console.log("Media delivered successfully: "+ awaitedNodeId);
                            awaitedNodeId = null;
                        }else if(localStream){
                            peer.call(awaitedNodeId, localStream);
                            console.log("Media sent successfully: "+ awaitedNodeId);
                            awaitedNodeId = null;
                        }else if(parent){
                            awaitedNodeId = data[1];
                            if(parent.open){
                                parent.send([4, peer.id]);
                            }
                        } else {
                            if(connIds.includes(data[1])){
                                conns[connIds.indexOf(data[1])].send([4]);
                            }
                        }
                        break;
                    default:
                        console.log("unknown data: " + data);
                }
            });

            
            conn.on('close', () => {
                for (let i = 0; i< conns.length; i++){
                    if(conns[i]){
                        if (conns[i].open){
                            continue;
                        }else{
                            let disconnectedGuest = connIds.indexOf(conns[i].peer);   // locate old data
                            if (disconnectedGuest !== -1){

                                let disconnectedAudience = audienceIds.indexOf(conns[i].peer);
                                if (disconnectedAudience !== -1){
                                    console.log("Disconnected and deleted: " + audienceIds[disconnectedAudience]);     //DEBUG
                                    audiences.splice(disconnectedAudience, 1);
                                    audienceIds.splice(disconnectedAudience, 1);
                                    
                                    let sameId = hereNode.indexOf(conns[i].peer);
                                    if(sameId !== -1){
                                        hereNode.splice(sameId, 3);     // remove disconnected audiences
                                        hereNode[2] = audienceIds.length;
                                        hereNode[3] = getRoomIds();
                                    
                                        // one of child nodes closed the connection
                                        console.log("nodesMap update after somebody closed")    // DEBUG
                                        if (parent){
                                            if (parent.open){
                                                parent.send(hereNode);
                                            }
                                        } else {
                                            nodesMap = Object.assign([], hereNode);
                                            nodesMap[1] = 1;
                                            liveSend(nodesMap);
                                        }
                                    }
                                }
                                // console.log("Disconnected and deleted: " + conns[i].peer);     //DEBUG
                                conns.splice(disconnectedGuest, 1);
                                connIds.splice(disconnectedGuest, 1);
                            }
                        }
                    }else{break;}
                }
            });
            
        });

        peer.on('call', (mediaOpenPort) => {
            mediaOpen = mediaOpenPort;
            // Receive the stream
            mediaOpen.on('stream', (stream) => {
                remoteStream = stream;
                if(awaitedNodeId){
                    peer.call(awaitedNodeId, remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                    console.log("Media delivered successfully: "+ awaitedNodeId);
                    awaitedNodeId = null;
                } else {
                    displayStream(remoteStream);
                }
                console.log('Received stream:', stream);    // DEBUG
            });
            mediaOpen.answer(null);
        });

        // // Click event for the send message button && parent uploads, conn receives the reply from the receiving party.
        // // *Explanation: In the given code snippet, here is an event listener attached to the "connectButton" element, which triggers a function when the button is clicked.
        // // *Inside the function, the "parent" variable is assigned the value of the connection made with the peer using the peer Id obtained from the input field with the Id "peerId".
        // document.getElementById('refreshButton').addEventListener('click', () => {
        //     document.getElementById("status").innerHTML="Status: Connecting..."
        //     tryConnect(0, urlId, false);
        // });

        function openRoomInfo() {       // top menu for showing the detail of room
            if(nodesMap[0] == undefined){
                alert("Error: void nodesMap");
                return;
            }
            if(openInfoTimes==0){
                    openInfoTimes++;
                    document.getElementById('openRoomInfo').style.height = "25%";
                }else{
                    openInfoTimes=0;
                    document.getElementById('openRoomInfo').style.height = "0px";
            }
            echoNodesMap(nodesMap, 0, undefined);
        }

        function streamSourceMenu(){
            if(document.getElementById('streamSource').style.height != "25%"){
                document.getElementById('streamSource').style.height = "25%";
            }else{
                document.getElementById('streamSource').style.height = "0px";
            } 
        }

        // autoScroll the scrollbar
        function autoScroll(){ ifAutoScroll = true;}
        function autoScrollStop(){ ifAutoScroll = false;}

        // Listen for press enter in message box
        document.getElementById("sendMessageBox").addEventListener('keypress', enter);
        function enter(e) {
            let event = e && window.event;
            if (event.which && event.keyCode == '13'){
                document.getElementById("sendButton").click();
            }
        }

        function showLive() {       // if usr want to live
            if((! parent) && openLiveTimes==0){
                openLiveTimes++;
                document.getElementById('liveSetting').style.height = "25%";
            }else{
                openLiveTimes=0;
                document.getElementById('liveSetting').style.height = "0px";
            }
        }
        
        MyName.addEventListener(
            "focusout",
            () => {
                if (MyName.value != hereNode[5] && MyName.value){
                    hereNode[5] = MyName.value;
                    if(parent){
                        parent.send(hereNode);
                    } else {
                        nodesMap = Object.assign([], hereNode);
                        nodesMap[1] = 1;
                        liveSend(nodesMap);
                    }
                }
            },
            true,
        );

        function autoJoin(t){   // special version for singleP2PLiveWeb
            if(nodesMap[1] !== 1){
                console.log("Error: try autoJoin() by the nodesMap which wasn't from Root of Room"+ nodesMap);
                return;
            }
            if(nodesMap[2] < t){        // host node has low child nodes
                tryConnect(1, nodesMap[4], true);
            } else {
                recursiveSearch(nodesMap, t, 1);   // search for the node with low child nodes
            }
        }

        function getRoomIds(){
            roomIds = new Array();
            if(parent){
                recursiveSearch(nodesMap, 999, 0);
            } else {
                recursiveSearch(hereNode, 999, 0);}
            return roomIds;
        }

        function recursiveSearch(arr, t, fnOfSearch){
            switch(fnOfSearch){
                case 0:     // search for getting ids of room
                    for (let i = 7; i < arr.length; i=i+3) {
                        if(arr[i] && arr[i + 2] instanceof Array){
                            if(arr[i + 2][2] < t){
                                roomIds.push(arr[i]);
                            }
                        }
                    }
                    for (let m = 9; m < arr.length; m=m+3) {    // After checked out suited nodes in thid layer, search their suited child nodes
                        if(arr[m] && arr[m] instanceof Array){
                            recursiveSearch(arr[m], t, 0);
                        }
                    }
                    break;
                case 1:
                    shallowSearch(arr, t);
                    while (temporaryChosedNodes[0] !== undefined) {
                        deeplySearch(temporaryChosedNodes, t);
                    }
                    break;
                default:
                    break;
            }
        }

        function shallowSearch(arr, t){
            for (let i = 7; i < arr.length; i=i+3) {
                if(arr[i] && arr[i + 2] instanceof Array){
                    if(arr[i + 2][2] < t){
                        if(ifConnectedAim){break;}
                        // console.log("tried connect to: "+ arr[i]);  // DEBUG
                        tryConnect(1, arr[i], true, false);
                    } else {
                        temporaryChosedNodes.push(arr[i+2]);    // record inapporpriate nodes for deep search
                    }
                }
            }   // else { console.log("give up connecting to "+ arr[i]); }
        }

        function deeplySearch(arr, t){
            let counter = arr.length;
            lastTemporaryChosedNodes = arr;
            temporaryChosedNodes = new Array();
            for (let w = 0; w < counter; w=w+1) {
                shallowSearch(lastTemporaryChosedNodes[w], t);
            }
        }

        // Send Massage and avoid delivering repeatedly
        function liveSend (msg){
            let aims = 0;     // count successful times
            if(parent){
                if( ! [msg[1], deliverId].includes(parent.peer)){    // Promise a stable sending
                    if(parent.open){     // check the data channel
                        parent.send(msg);
                        aims++;  // count successful times
                    }
                }
            }
            if(audiences){
                for(let i=0; i<audiences.length; i++){
                    if(audiences[i]){
                        if( ! [msg[1], deliverId /*, parent.id */].includes(audiences[i].peer)){
                            if(audiences[i].open){
                                audiences[i].send(msg);
                                aims++;
                            }
                        }
                    }
                }
            }
            deliverId = null;    // avoid losing text when sending
            return aims;    //if == zero => send failed
        }

        function refreshMap(fnOfEcho){
            document.getElementById("roomTitle").innerHTML = nodesMap[4];
            document.getElementById("roomSummary").innerHTML = nodesMap[5];
            document.getElementById("roomCover").src = nodesMap[6];
            echoNodesMap(nodesMap[9], 0, undefined, fnOfEcho);    // refresh the menu
        }

        function echoNodesMap(arr, layerNumber, aimId, fnOfEcho){
            if(arr == nodesMap[9]){      // refresh Map for "refresh" & hostNode button
                layers = [0];
                if(aimId === undefined){     // hostNode button provide the channel connecting to host
                    lastAimId = null;
                }
                lastLayerNumber = null;
                document.getElementById("block0").innerHTML = "";
                document.getElementById("block1").innerHTML = "";
            }
            if(lastAimId === aimId){  // if second click on same button
                switch (fnOfEcho) {
                    case 0:     // button for getting id
                        if(aimId){
                            alert(aimId);
                        }
                        break;
                    case 1:     // button for joining a node
                        if(aimId == peer.id){alert(aimId);break;}
                        document.location.href = "./P2PLiveAudience.html?id=" + aimId +"&name="+ getMyName();
                        break;
                    case 2:     // button for joining a node
                        if(aimId == peer.id){alert(aimId);break;}
                        document.location.href = "./P2PGameFiveOnLinePlayer.html?id=" + aimId +"&name="+ getMyName();
                        break;
                }
            }else{
                document.getElementById("block"+ layerNumber % 2).innerHTML = "";
                if(lastLayerNumber === layerNumber ){
                    layers.splice(lastLayerNumber + 1);  // remove all of old layers
                }
                if(arr){
                    for(let i = 7; i < arr.length; i=i+3){
                        if(arr[i + 2] instanceof Array){    // create buttons linking to child nodes of object which was delivered by clicked button
                            document.getElementById("block"+ layerNumber % 2).innerHTML = document.getElementById("block"+ layerNumber % 2).innerHTML + "<button class=\"childNodes\" onclick=\"echoNodesMap(layers["+ (layerNumber + 1) +"]["+ (i+2) +"], "+ (layerNumber + 1) +", layers["+ (layerNumber + 1) +"]["+ i +"], "+ fnOfEcho +" )\">"+ arr[i + 1] +"</button><br />";
                        }
                    }
                }
                layers.push(arr);
                lastLayerNumber = layerNumber;
                lastAimId = aimId; // original id of this layer
            }
        }

        // *Explanation: This comment indicates that the following code block is responsible for sending a message.
        // *It serves as a brief description of the purpose of the code.
        function sendMsg() {   //*This line of code adds an event listener to the element with the ID "sendButton". It listens for a click event on the button and triggers the provided function when the event occurs.
            let msg = [ 0, peer.id, document.getElementById("name").value, document.getElementById("sendMessageBox").value, msgImgBase64];   //*This line of code creates an array called "msg" and assigns it two values. The first value is the value of the element with the ID "name", and the second value is the value of the element with the ID "sendMessageBox". These values are used to construct the message that will be sent.
            if (msg[3] || msg[4]){    // DEBUG *This condition checks if the second element of the "msg" array (i.e., the message content) exists and is not empty.
                if ( liveSend(msg) > 0 ) {   // *This condition checks if the "liveSend" function returns a value greater than 0 when called with the "msg" array and 0 as arguments. If it does, it means the message was sent successfully.
                    appearMsg(msg);     // This function is responsible for displaying the own sent message
                    document.getElementById("sendMessageBox").value = "";
                    // console.log("Sent successfully: " + msg);    // DEBUG
                    msgImgBase64 = null;
                    document.getElementById("msgImgInput").files = null;
                }else{console.log('Connection is closed');}
            }else{
                document.getElementById("sendMessageBox").setAttribute("placeholder","Void content!!!!!!!!!!!!!!"); //*This line of code sets the placeholder attribute of the element with the ID "sendMessageBox" to display a message indicating that the content should not be empty.
            }
        }

        function sendImg(){
            let file = document.getElementById("msgImgInput").files[0];
            let reader = new FileReader();
            if(file){
                if(file.size <= 1048576){
                    reader.readAsDataURL(file);
                    reader.onloadend = () => {
                        msgImgBase64 = reader.result;
                    }
                } else {
                    alert("it can't over 1MB");
                }
            } else {
                console.log("img transformed Error!");
            }
        }

        // add msg to box
        function appearMsg(msg) {
            let now = new Date();
            if(msg[4]){
                let img = "<img style=\"max-width: 100px; max-height: 100px; object-fit: contain;\" src=\""+ msg[4] +"\">";
            } else {
                let img = "";
            }
            document.getElementById("chatBox").innerHTML =  document.getElementById("chatBox").innerHTML + "<div class=\"msgs\"><span class=\"time\">[" + now.getHours() +":"+ now.getMinutes() +":"+ now.getSeconds() + "]</span>" + "<span class=\"usr\">"+ msg[2] + ": </span>" + msg[3] + img +"</div>";
            if(ifAutoScroll){
                document.getElementById('chatBox').scrollTop = document.getElementById('chatBox').scrollHeight;
            }
            if(ifAutoClean.checked){
                let msgs = document.getElementsByClassName("msgs");
                let numberOfMsgs = msgs.length;
                if(numberOfMsgs > 100){
                    let deltaNumber = numberOfMsgs - 100;
                    for(let i=0; i <= deltaNumber; i++){
                        msgs[i].remove();
                        numberOfMsgs--;
                    }
                }
            }
            if(fullWebVideoTimes === 1){
                document.getElementById("chatBox").style.visibility="true";
                setTimeout(function(){document.getElementById("chatBox").style.visibility="false";}, 5000)
            }
        }

        function cleanMsg(){    // DEBUG
            let msgs = document.getElementsByClassName("msgs");
            while(msgs.length){
                msgs[0].remove();
            }
        }

        function getMyName(){
            if(MyName){
                if (MyName.value){
                    return MyName.value;
                } else {
                    return peer.id;
                }
            }
        }

        // the function of getting local stream(It can't work on most of mobile phone)
        // Please note! In order for the getDisplayMedia() method to work properly, you need to use the HTTPS protocol or run it on localhost in a local development environment.
        // Otherwise, the browser may restrict access to the camera and microphone.
        function useDisplayMedia() {
            navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }).then((stream) => {
                    // After successfully obtaining the local stream, display it on the page.
                    if( ! document.getElementById("ifNotDisplayLocalStream").checked){
                        displayStream(stream);  // for debug
                    } else {
                        WebVideo.srcObject = null;
                    }
                    localStream = stream;
                    console.log("Local stream shared");
                })
                .catch((error) => {
                    console.error('Error getting local stream:', error);
                });
        }

        function askNavigatorMediaDevices(){
            let constraints = { audio: document.getElementById("ifUseCamera").checked, video: document.getElementById("ifUseMicrophone").checked };
            navigator.mediaDevices
                .getUserMedia(constraints)
                .then(function (stream) {
                    // After successfully obtaining the local stream, display it on the page.
                    if( ! document.getElementById("ifNotDisplayLocalStream").checked){
                        displayStream(stream);  // for debug
                    } else {
                        WebVideo.srcObject = null;
                    }
                    localStream = stream;
                    console.log("Local stream shared");
                })
                .catch(function (err) {
                    console.error('Error getting local stream:', err);
                });
        }
                
        // display the remote stream and try to play it(if usr didn't do anything on web maybe be prohibited)
        function displayStream(stream) {
            if(WebVideo.srcObject){
                WebVideo.srcObject = null;
            }
            WebVideo.srcObject = stream;
        }

        function refreshMedia(){
            if(remoteStream){
                displayStream(remoteStream);
            } else if(parent){
                if(parent.open){
                    parent.send([4, peer.id]);
                }
            } else if(localStream){
                displayStream(localStream);
            }
        }

        // transform Img into Base64
        function liveCoverInput(){
            let file = document.getElementById("LiveCoverInput").files[0];
            let reader = new FileReader();
            if(file){
                if(file.size <= 1048576){
                    reader.readAsDataURL(file);
                    reader.onloadend = () => {
                        liveCoverBase64 = reader.result;
                    }
                } else {
                    alert("it can't over 1MB");
                }
            } else {
                console.log("img transformed Error!");
            }
        }

        function fullWebVideo(){
            if(fullWebVideoTimes === 0){
                WebVideo.style.height = window.innerHeight + "px";
                WebVideo.style.width = window.innerWidth + "px";
                window.scrollBy({
                    top: document.documentElement.scrollHeight,
                    behavior: "smooth",
                });
                fullWebVideoTimes++;
            } else {
                WebVideo.style.height = "100%";
                WebVideo.style.width = "100%";
                fullWebVideoTimes = 0;
            }
            
        }

        function tryConnect(object, id, ifJump, ifAskForMediaStream){
            // object:
            // 0: parent
            // 1: guest
            // 2: bridge
            // 3: root
            // 4: indexRoot
            switch (object) {
                case 0:
                    // Close old connection
                    if (parent) {
                        parent.close();
                        // [ mark of sorting, myId, number of who be effected, if keep parent firmly here ]
                        liveSend([3, peer.id, 0, false]);     // remind child node change parentNode
                    }
                    parent = peer.connect(id);

                    parent.on('open', () => {
                        // changingParentConnection = false;
                        parent.send(hereNode);
                        document.getElementById("status").innerHTML="Status: Connected to Live Room Successfully!"
                        appearMsg([ 0, null, "System", "Connected successfully"]);
                    });
                    
                    // parent.on('error', (err) => {
                    //     document.getElementById("status").innerHTML="Status: Connecting Failed!" + err;
                    // });

                    // Receive the reply of text: Host --> Guset
                    parent.on('data', (data) => {
                        // data[0]:
                        //  0: nodeInfo or indexRoomInfo 
                        //  1: msg
                        //  2: streaming request
                        //  3: for reconnect: Remind the child node to replace the parent node
                        //  4: for refresh: apply to the new media Stream for daliver to child
                        switch (data[0]) {
                            case 0:
                                // console.log('Received data:', data); // DEBUG
                                deliverId = data[1];
                                data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                                
                                if ( liveSend(data) > 0 ) {
                                    console.log("Msg delivered successfully: " + data);
                                }else{console.log('Msg delivered failed');}
                                
                                appearMsg(data);
                                break;
                            case 1:
                                if (data[1] == -1){ break; }    // refused to receive msg for guest
                                recorder(data);
                                break;
                            case 3:     // for single version
                                if(data[2] > 0 || data[3] == true){    // if it isn't the first node without correct parent node -> didn't auto changing the parent node
                                    RemoteVideo.src = null;
                                    remoteStream = null;
                                    mediaOpen.close();
                                    data[2]++;
                                    // optional setting
                                    // if(data[2]%5 == 0){
                                    //     autoJoin(nodesMap, 2, 0);
                                    // }
                                    liveSend(data);
                                    document.getElementById("status").innerHTML="Status: awaitng parent node autoReConnect to room( You can also ReConnect by yourself)!"
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    })
                                    break;
                                }
                                // changingParentConnection = true;
                                parent.close();
                                if(document.getElementById('ifAutoReconnect').checked){
                                    data[2]++;   // report child nodes await parent autoReConntect room
                                    liveSend(data);     
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    });
                                } else {
                                    data[3] = true;
                                    liveSend(data);
                                }
                                break;
                            case 4:
                                // if deliver without meida stream
                                if(awaitedNodeId){
                                    if(connIds.includes(awaitedNodeId)){
                                        conns[connIds.indexOf(awaitedNodeId)].send([4]);
                                        awaitedNodeId = null;
                                    }
                                } else {
                                    alert("host is not on live");
                                }
                            default:
                                console.log("unknown data: " + data);
                        }
                    });

                    parent.on('close', () => {
                        document.getElementById("status").innerHTML="Status: Room Connection Closed. Please Refresh the Connection!"

                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="Status: Reconnecting to room...";
                            
                            autoJoin(3);
                            
                        }
                    });
                    break;
                    
                case 1:
                    if(guest){if(guest.open){
                        guest.close();
                    }}
                    guest = peer.connect(id);
                    
                    if(ifJump){
                        guest.on('open', () => {
                            for(let i=0; i<guests.length; i++){
                                guest = guests[i];
                                guests = new Array();   // break all of conn
                                ifConnectedAim = true;
                                document.location.href = "./SingleP2PLiveVersion.html?name="+ getMyName();
                                // console.log("aim id of node: "+ guest.peer)  // DEBUG
                                break;
                            }
                        });
                        if(! ifConnectedAim){
                            guests.push(guest);
                        }
                    } else {
                        if(ifAskForMediaStream){
                            guest.on('open', () => {
                                guest.send([2, peer.id, getMyName()]);
                            });
                            
                            peer.on('call', (mediaOpenPort) => {
                                mediaOpen = mediaOpenPort;
                                // Receive the stream
                                mediaOpen.on('stream', (stream) => {
                                    localStream = stream;
                                    if( ! document.getElementById("ifNotDisplayLocalStream").checked){
                                        displayStream(stream);
                                    }
                                });
                                mediaOpen.answer(null);
                            });
                        } else {
                            guest.on('data', (data) => {
                                for(let i=0; i<guests.length; i++){
                                    if(guests[i].open){     // maybe useless
                                        guest = guests[i];
                                        guests = new Array();   // break all of conn
                                        nodesMap = data;
                                        ifConnectedAim = true;
                                        guest.on('data', () => {
                                            ifConnectedAim = false;
                                        });
                                        break;
                                    }
                                }
                            });
                            if(! ifConnectedAim){
                                guests.push(guest);
                            }
                        }
                    }
                    break;
                case 2:
                    if (bridge) {
                        bridge.close();
                    }
                    bridge = peer.connect(id);
                    alert("try to connect someone in rooms");
                default:
                    console.log("tryConnect Error");
                    break;
            }
        }

        function echoNodesMap(arr, layerNumber, aimId){
            if(arr == nodesMap){      // refresh Map for "refresh" & hostNode button
                layers = [0];
                if(aimId === undefined){     // hostNode button provide the channel connecting to host
                    lastAimId = null;
                }
                lastLayerNumber = null;
                document.getElementById("block0").innerHTML = "";
                document.getElementById("block1").innerHTML = "";
            }
            if(lastAimId === aimId){  // if second click on same button
                if(aimId){
                    alert(aimId);
                }
            }else{
                document.getElementById("block"+ layerNumber % 2).innerHTML = "";
                if(lastLayerNumber === layerNumber ){
                    layers.splice(lastLayerNumber + 1);  // remove all of old layers
                }
                if(arr){
                    for(let i = 7; i < arr.length; i=i+3){
                        if(arr[i + 2] instanceof Array){    // create buttons linking to child nodes of object which was delivered by clicked button
                            document.getElementById("block"+ layerNumber % 2).innerHTML = document.getElementById("block"+ layerNumber % 2).innerHTML + "<button class=\"childNodes\" onclick=\"echoNodesMap(layers["+ (layerNumber + 1) +"]["+ (i+2) +"], "+ (layerNumber + 1) +", layers["+ (layerNumber + 1) +"]["+ i +"])\">"+ arr[i + 1] +"</button><br />";
                        }
                    }
                }
                layers.push(arr);
                lastLayerNumber = layerNumber;
                lastAimId = aimId; // original id of this layer
            }
        }

        function recorder(data){
            switch (data[1]){
                case 0:     // 0 means unfinished
                    let sameId = hereNode.indexOf(data[4]);   // locate old data
                    console.log('Info of nodes updated:', data);
                    // let idTemp = Object.assign({}, connPeers);     // make connIds value stable
                    if(sameId === -1){
                        hereNode.push(data[4]);
                        hereNode.push(data[5]);
                        hereNode.push(data);
                    } else {
                        hereNode[ sameId + 1 ] = data[5];
                        hereNode[ sameId + 2 ] = data;      // replace old data
                    }
                    // let idTemp = Object.assign({}, connIds);     // make connIds value stable
                    // idTemp[sameId] = data;      // replace old data
                    // hereMap = [1, peer.id, idTemp, null, 0];  //record this node's info
                    hereNode[2] = audienceIds.length;
                    if(parent){
                        if(parent.open){       // collect information about the connection map and send to parent node
                            parent.send(hereNode);   // if not root node
                        }
                    } else {
                        hereNode[3] = getRoomIds();
                        nodesMap = Object.assign([], hereNode);
                        nodesMap[1] = 1;
                        liveSend(nodesMap);
                        document.getElementById("sumOfRoom").innerHTML = "Audiences: "+ nodesMap[9][3].length;
                    }
                    break;
                case 1:    // once collection of data is completed            
                    for(let i=0; i<audiences.length; i++){     // send nodesMap to everyone
                        if(audiences[i]){
                            if(audiences[i].open){
                                audiences[i].send(data);
                            }
                        }
                    }
                    nodesMap = data;
                    document.getElementById("sumOfRoom").innerHTML = "Audiences: "+ nodesMap[9][3].length;
                    break;
                default:
                    console.log("unknown data" + data);
                    break;
            }
        }

    </script>
</body>
</html>