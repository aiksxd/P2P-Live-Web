<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
    <!-- Detail of Room -->
    <div id="openRoomInfo">
        <img id="roomCover" src="">
        <div id="roomText">
            <div id="roomTitle"></div>
            <textarea id="roomSummary" rows="5" cols="33" readonly="readonly"></textarea>
            <div id="nodeInfo">
                <div id="stable">
                    <button id="hostBlock" onclick="echoNodesMap(nodesMap[9], 0, nodesMap[7], 1)">Host Node</button>
                    <button id="refreshMap" onclick="refreshMap(1)">Refresh</button>
                </div>
                <div id="block0"></div>
                <div id="block1"></div>
            </div>
        </div>
        <button id="autoJoin" class="actionButton" onclick="autoJoin(3)">auto<br />Join</button>
        <button id="closeInfo" class="actionButton" onclick="openRoomInfo()">Close</button>
    </div>
    
    <!-- Stream Source -->
    <div id="streamSource">
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Share PC Desktop:<br />
                <button type="button" id="browserDisplayMedia" onclick="useDisplayMedia()">Use Display Stream</button>
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Share Local Devices(PE, PC...):
                <button type="button" id="browserNavigatorMediaDevices" onclick="askNavigatorMediaDevices()">Upload Local Device</button><br />
                <input type="checkbox" id="ifUseCamera">Camera
                <input type="checkbox" id="ifUseMicrophone">Microphone
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                Lend Media Stream From Others
                <input id="lendAimId" type="text" placeholder="input ID OF AIM here...">
                <button type="button" id="lendStream" onclick="tryConnect(1, document.getElementById('lendAimId').value, false, true)">lend aim stream( need be accepted )</button>    
            </div>
        </div>
        <div class="box" style="margin-top: 10px;">
            <div style="font-weight: bold;">
                <input type="checkbox" id="ifNotDisplayLocalStream">If Display the localStream <br />
                —— enable for saving performance of devices
            </div>
        </div>
        <button class="actionButton" id="submitMediaStream" onclick="streamSourceMenu()">submit</button>
    </div>

    <!-- Id interaction -->
    <div class="container">
        <div class="box">
            <!-- Sender -->
            <div style="font-weight: bold;">Audience</div>
            <!-- Connect box -->
            <button id="refreshButton" onclick="refreshMedia()">Refresh</button>
            <button id="openRoomInfoButton" onclick="openRoomInfo()">Room Info</button>
            <div id="myid" style="font-weight: bold;">Connecting to PeerServer...</div>
            <div id="status" style="font-weight: bold;">Status: Waiting to Connecting to PeerServer...</div>
            <input type="checkbox" id="ifAutoReconnect" checked="checked">Automatic Reconnection<br />
        </div>
        <div class="box">
            <button onclick="fullWebVideo()">Full Web Video</button><br />
            <div>
                <img id="myIcon" style="width: 32px; height: 32px;"><div style="display: inline-block;">Custome Icon & Name<br/><input type="text" id="name" placeholder="Input your name here..." /></div><br />
                <input type="file" name="icon" id="uploadIcon" onchange="iconInput()">
            </div>
            <input type="checkbox" id="predictive">Predictive<br />
        </div>
        <div class="box" style="width: 30%;">
            <div id="playersList"></div>
            <span id="nowTurn">Now Turn: 1 </span>
            <span id="sumOfRoom">Members: 1</span><br />
            <input type="checkbox" id="ifAutoClean">Auto-clean Msgs[max to 100]<br />
        </div>
    </div>
    
    <!-- Live interaction-->
    <div class="videoBox">
        <div id="canvasMap" style="position: absolute;">
            <br /><br /><br /><br />
            MapSize: Height:<input type="number" id="maxHeight" class="tidy" value="10" readonly> Width:<input type="number" id="maxWidth" class="tidy" value="10" disabled="true"><br />
            MaxPlayers: <input type="number" id="maxPlayers" class="tidy" value="5" readonly><br />
            GameMode: <select id="gameMode" disabled>
                <option value="0" selected="selected">SLG Mode</option>
                <option value="1">Energy Mode</option>
                <option value="2">Card Mode</option>
            </select><br />
            HostJoinGame: <input type="checkbox" checked="true" class="tidy" id="hostJoinGame" disabled><br />
            <button id="join" onclick="parent.send([8, 0, peer.id, myIcon, getMyName()])">Join Game</button>
        </div>
        <!-- Message box -->
        <div id="chatContainer">
            <div id="chatBox"></div>
            <div class="sendInput">
                <!-- Send box -->
                <input type="text" id="sendMessageBox" placeholder="Input message here..." autofocus="true" />
                <button type="button" id="sendButton" onclick="sendMsg()">Send</button>
                <button type="button" id="uploadImgButton">Img</button><br />
                <input id="msgImgInput" type="file" onchange="sendImg()" style="display: none;">
            </div>
        </div>
    </div>
    <script src="js/peerjs.min.js"></script>
    <!--script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script-->
    <script src="js/fn.js"></script>
    <script>
        let openInfoTimes = 0;
        let lastAimId = null;
        let layers = [0];
        let mediaOpen = null;
        let parent = null;
        let ifAutoScroll = true;
        let ifConnectedAim = false;
        let remoteStream = null;
        let localStream = null;
        let audiences = new Array();
        let audienceIds = new Array();
        let conn = null;
        let conns = new Array();
        let connIds = new Array();
        let nodesMap = new Array();
        let params = new URLSearchParams(document.location.search.substring(1));
        let urlId = params.get("id");
        let urlName = params.get("name");
        let hereNode = new Array();
        let changingParentConnection = false;
        let ifHitAim = false;
        let lastLayerNumber = null;
        let awaitedNodeId = null;
        const MyName = document.getElementById("name");
        const WebVideo = document.getElementById('canvasMap');
        
        // For game
        let players = [5];
        let deliver = null;
        let unavailablePosition = [];
        let positionOwners = [];
        let clickTimes = 0;
        let lastAimPosition = 0;
        let chessmanCode_0_Cost = 3;
        let leftEnergy = 0;
        let lastOperationTime = 0;
        let positonDeliver = null;
        let turn = 1;
        let maxEnergy = 5;
        let chessmanCode_1_Cost = 3;
        let gameMode = [0];
        let maxHeight = 10;
        let maxWidth = 10;
        let mapSize = [maxHeight, maxWidth];
        let gameMap = [mapSize]
        let startTime = null;
        let myNumber = null;
        let offlinePlayer = [];
        let lastGameMap = null;
        let gameInfo = [6, players, gameMap, gameMode, startTime, unavailablePosition, positionOwners];
        
        // Listen for the event when a Peer connection is successfully opened
        // *Explanation: The provided code snippet is using the Peer.js library to establish a Peer connection. The peer.on('open', ...) code block is listening for the 'open' event, which is triggered when the Peer connection is successfully opened.
        peer.on('open', (id) => {
            MyName.value = urlName;
            hereNode = [ 1, 0, 0, [], id, getMyName(), []]
            console.log(id);
            document.getElementById("myid").innerHTML = "Your Id:<br/>" + id;
            document.getElementById("status").innerHTML="Status: Connecting to Live Room...";
            tryConnect( 0, urlId, false);   // try to connect to the room
        });

        // When a new connection request is received, this code creates a data channel and sends the local or remote stream (if available) and text messages.
        peer.on('connection', (connPort) => {
            connIds.push(connPort.peer);
            conns.push(connPort);
            conn = connPort;

            conn.on('open', () => {
                // for guest in index
                let sendNodesMap = nodesMap;
                sendNodesMap[2] = -1;
                conn.send(sendNodesMap);
            });

            // Receive the text: Host <-- Parent
            conn.on('data', (data) => {
                // data[0]:
                //  0: msg
                //  1: nodeInfo or indexRoomInfo 
                //  2: roomInfoModfied
                //  3: for reconnect: Remind the child node to replace the parent node
                //  4: for refresh: apply to the new media Stream for daliver to child
                switch (data[0]) {
                    case 0:
                        console.log('Received data:', data);
                        deliverId = data[1];
                        data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                        
                        if ( liveSend(data) > 0 ) {
                            console.log("Msg delivered successfully: " + data);
                        }else{console.log('Msg delivered failed');}
                        
                        appearMsg(data);
                        break;
                    case 1:
                        if ( ! audienceIds.includes(data[4])){
                            let aimPosition = connIds.indexOf(data[4]);
                            audienceIds.push(connIds[aimPosition]);
                            audiences.push(conns[aimPosition]);

                            // for game:
                            conns[aimPosition].send(gameInfo);

                            console.log("Msg Connected to: " + data[4]);

                            // if(remoteStream){      // speed debug todo
                            //     peer.call(data[4], remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                            //     console.log("Media delivered successfully: "+ data[4]);
                            // }else if(localStream){
                            //     peer.call(data[4], localStream);
                            //     console.log("Media sent successfully: "+ data[4]);
                            //     // If you want to receive the reply of the stream
                            //     // usage: let temp peer.call(conn.peer, localStream);
                            //     // temp.on('stream', (stream) = displayStream);
                            //     // PS:
                            //     // It can only receive the previous one, so you need to deliver a new stream. 
                            // }
                        }
                        recorder(data);
                        break;
                    case 2:
                        if(data[1] && confirm(data[2]+"("+ data[1] +") ask for your media stream")){
                            if(localStream){
                                peer.call(data[1], localStream);
                            } else if(remoteStream){
                                peer.call(data[1], remoteStream);
                            } else {
                                streamSourceMenu();
                                document.getElementById('submitMediaStream').addEventListener('click', () => {
                                    peer.call(data[1], localStream);
                                });
                            }
                        }
                        break;
                    case 4:
                        if(remoteStream){
                            peer.call(awaitedNodeId, remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                            console.log("Media delivered successfully: "+ awaitedNodeId);
                            awaitedNodeId = null;
                        }else if(localStream){
                            peer.call(awaitedNodeId, localStream);
                            console.log("Media sent successfully: "+ awaitedNodeId);
                            awaitedNodeId = null;
                        }else if(parent){
                            awaitedNodeId = data[1];
                            if(parent.open){
                                parent.send([4, peer.id]);
                            }
                        }
                        break;
                    default:
                        console.log("unknown data: " + data);
                }
            });

            
            conn.on('close', () => {
                for (let i = 0; i< conns.length; i++){
                    if(conns[i]){
                        if (conns[i].open){
                            continue;
                        }else{
                            let disconnectedGuest = connIds.indexOf(conns[i].peer);   // locate old data
                            if (disconnectedGuest !== -1){

                                let disconnectedAudience = audienceIds.indexOf(conns[i].peer);
                                if (disconnectedAudience !== -1){
                                    console.log("Disconnected and deleted: " + audienceIds[disconnectedAudience]);     //DEBUG
                                    audiences.splice(disconnectedAudience, 1);
                                    audienceIds.splice(disconnectedAudience, 1);
                                    
                                    let sameId = hereNode.indexOf(conns[i].peer);
                                    if(sameId !== -1){
                                        hereNode.splice(sameId, 3);     // remove disconnected audiences
                                        hereNode[2] = audienceIds.length;
                                    
                                        // one of child nodes closed the connection
                                        console.log("nodesMap update after somebody closed")    // DEBUG
                                        if (parent){
                                            if (parent.open){
                                                parent.send(hereNode);
                                            }
                                        }

                                    }
                                }
                                // console.log("Disconnected and deleted: " + conns[i].peer);     //DEBUG
                                conns.splice(disconnectedGuest, 1);
                                connIds.splice(disconnectedGuest, 1);
                            }
                        }
                    }else{break;}
                }
            });
            
        });

        peer.on('call', (mediaOpenPort) => {
            mediaOpen = mediaOpenPort;
            // Receive the stream
            mediaOpen.on('stream', (stream) => {
                remoteStream = stream;
                if(awaitedNodeId){
                    peer.call(awaitedNodeId, remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                    console.log("Media delivered successfully: "+ awaitedNodeId);
                    awaitedNodeId = null;
                } else {
                    displayStream(remoteStream);
                }
                console.log('Received stream:', stream);    // DEBUG
            });
            mediaOpen.answer(null);
        });

        function tryConnect(object, id, ifJump, ifAskForMediaStream){   // for fiveOnline Version
            // object:
            // 0: parent
            // 1: guest
            // 2: bridge
            // 3: root
            // 4: indexRoot
            switch (object) {
                case 0:
                    // Close old connection
                    if (parent) {
                        parent.close();
                        // [ mark of sorting, myId, number of who be effected, if keep parent firmly here ]
                        liveSend([3, peer.id, 0, false]);     // remind child node change parentNode
                    }
                    parent = peer.connect(id);

                    // Receive the reply of text: Host --> Guset
                    parent.on('data', (data) => {
                        // data[0]:
                        //  0: nodeInfo or indexRoomInfo 
                        //  1: msg
                        //  2: streaming request
                        //  3: for reconnect: Remind the child node to replace the parent node
                        //  4: for refresh: apply to the new media Stream for daliver to child

                        // fiveOnline:
                        // 6: gameInfo
                        // 7: chessman
                        // 8: player
                        switch (data[0]) {
                            case 0:
                                // console.log('Received data:', data); // DEBUG
                                deliverId = data[1];
                                data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                                
                                if ( liveSend(data) > 0 ) {
                                    console.log("Msg delivered successfully: " + data);
                                }else{console.log('Msg delivered failed');}
                                
                                appearMsg(data);
                                break;
                            case 1:
                                if (data[1] == -1){ break; }    // refused to receive msg for guest
                                recorder(data);
                                break;
                            case 3:     // for single version
                                if(data[2] > 0 || data[3] == true){    // if it isn't the first node without correct parent node -> didn't auto changing the parent node
                                    RemoteVideo.src = null;
                                    remoteStream = null;
                                    mediaOpen.close();
                                    data[2]++;
                                    // optional setting
                                    // if(data[2]%5 == 0){
                                    //     autoJoin(nodesMap, 2, 0);
                                    // }
                                    liveSend(data);
                                    document.getElementById("status").innerHTML="Status: awaitng parent node autoReConnect to room( You can also ReConnect by yourself)!"
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    })
                                    break;
                                }
                                // changingParentConnection = true;
                                parent.close();
                                if(document.getElementById('ifAutoReconnect').checked){
                                    data[2]++;   // report child nodes await parent autoReConntect room
                                    liveSend(data);     
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    });
                                } else {
                                    data[3] = true;
                                    liveSend(data);
                                }
                                break;
                            case 6:
                                let i = 1;
                                if(data[4]){   // already started
                                    startTime = data[4];
                                    players[0] = data[1][0];
                                    gameMap = data[2];
                                    mapSize = gameMap[0];
                                    maxHeight = mapSize[0];
                                    maxWidth = mapSize[1];
                                    gameMode = data[3];
                                    if (data[1][1]) {  // firstly receive gameInfo
                                        let i = 1;
                                        gameInfo = data;
                                        players = gameInfo[1];
                                        while(i<players.length){
                                            displayNewPlayer(players[i]);
                                            i++;
                                        }
                                    }   // because of no sense of void player game, it is without dealing with new gameInfo which is hasn't any player
                                    drawMap();
                                } else {
                                    document.getElementById("maxHeight").value = String(data[2][0][0]);
                                    document.getElementById("maxWidth").value = String(data[2][0][1]);
                                    document.getElementById("maxPlayers").value = String(data[1][0]);
                                    document.getElementById("gameMode").selectedIndex = data[3][0];
                                    document.getElementById("hostJoinGame").checked = data[3][1];
                                    // document.getElementById("canvasMap").innerHTML = "<div id=\"canvasMap\" <br><br><br><br> MapSize: Height:"+ data[2][0][0] +" Width:"+ data[2][0][1] +"<br> MaxPlayers:"+ data[1][0] +" <br> GameMode:"+ data[3][0] +" <br> HostJoinGame:"+ data[3][1] +" <br> <button id=\"join\" onclick=\"parent.send([8, 0, peer.id, myIcon, getMyName()])\">Join Game</button> </div>"

                                    if (data[1][1]) {  // firstly receive gameInfo
                                        gameInfo = data;
                                        let i = 1;
                                        players = gameInfo[1];
                                        while(i<players.length){
                                            displayNewPlayer(players[i]);
                                            i++;
                                        }
                                    } else {
                                        let temp = gameInfo[1]; // keep old
                                        gameInfo = data;
                                        gameInfo[1] = temp;
                                    }
                                }
                                break;
                            case 7:
                                switch (data[1]) {
                                    case 0:
                                        parent.send(data);
                                        break;
                                    case 1:
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        gameMap.push(data[2]);
                                        drawChessman(data[2], data[3]);
                                        if(deliver && turn == myTurn){
                                            applyForPut(deliver);
                                        }
                                        break;
                                    default:
                                        console.log("unknown data: " + data);
                                        break;
                                }
                                break;
                            case 8:
                                switch (data[1]) {
                                    case 0:     // SB will join the game
                                        parent.send(data);
                                        break;
                                    case 1:
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        players.push(data[2]);
                                        if(data[2][1] == peer.id){
                                            myNumber = data[2][0];
                                            if(document.getElementById("join")){
                                                document.getElementById("join").innerHTML = "Cancel";
                                            }
                                        }
                                        displayNewPlayer(data[2]);
                                    case 2:     // kick SB
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        if(data[2] == myNumber){
                                            myNumber = null;
                                            if(document.getElementById("join")){
                                                document.getElementById("join").innerHTML = "Join Game";
                                            }
                                        }
                                        let i = 1;
                                        let position = false;
                                        while(i<players.length){
                                            if(players[i] instanceof Array){
                                                if(position){
                                                    players[i][0]--;
                                                    document.getElementsByClassName("playersInfo")[i-1].children[0].innerHTML = i+": ";
                                                    if(!players[i][2]){
                                                        player = players[i];
                                                        let colour = 255*((player[0] + 2)/(player[0] + 4));
                                                        document.getElementsByClassName("playersInfo")[i-1].children[1].setAttribute("style", "background-color: rgb("+parseInt(((((player[0]+1) % 5) + 1)/5)*colour)+", "+parseInt(((((player[0]+1) % 4) + 1)/4)*colour)+", "+parseInt(((((player[0]+1) % 3) + 1)/3)*colour)+")");
                                                    }
                                                }
                                                if(players[i][0] == data[2] && (!position)){   // refer to number
                                                    players.splice(i, 1);
                                                    document.getElementsByClassName("playersInfo")[i-1].remove();
                                                    position = i;   // changed
                                                } else {
                                                    i++;
                                                }
                                            } else {i++;}
                                        }
                                        if(position){
                                            if(position < myNumber){
                                                myNumber--;
                                            }
                                        }
                                        if(turn >= players.length){
                                            trun = 1;
                                            document.getElementById("nowTurn").innerHTML = "Now Turn: "+turn+" ";
                                        }
                                        // if(data[3] == peer.id){
                                        //     peer.distory();
                                        // } else if (audienceIds.includes(data[3])){
                                        //     audiences[audienceIds.indexOf(data[3])].close();
                                        // }
                                        // appearMsg("...");   // kick Msg todo
                                        break;
                                    default:
                                        console.log("unknown data: " + data);
                                        break;
                                }
                                break;
                            default:
                                console.log("unknown data: " + data);
                        }
                    });

                    parent.on('open', () => {
                        // changingParentConnection = false;
                        parent.send(hereNode);
                        document.getElementById("status").innerHTML="Status: Connected to Live Room Successfully!"
                        appearMsg([ 0, null, "System", "Connected successfully"]);
                    });
                    
                    // parent.on('error', (err) => {
                    //     document.getElementById("status").innerHTML="Status: Connecting Failed!" + err;
                    // });

                    parent.on('close', () => {
                        document.getElementById("status").innerHTML="Status: Room Connection Closed. Please Refresh the Connection!"

                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="Status: Reconnecting to room...";
                            
                            autoJoin(3);
                            
                        }
                    });
                    break;
                    
                case 1:
                    if(guest){if(guest.open){
                        guest.close();
                    }}
                    guest = peer.connect(id);
                    
                    if(ifJump){
                        guest.on('open', () => {
                            for(let i=0; i<guests.length; i++){
                                guest = guests[i];
                                guests = new Array();   // break all of conn
                                ifConnectedAim = true;
                                switch (gameInfo[0]) {
                                    case 0:
                                        document.location.href = "./P2PLiveAudience.html?id="+ guest.peer +"&name="+ getMyName();       
                                        break;
                                    case 1:
                                        document.location.href = "./P2PGameFiveOnLinePlayer.html?id="+ guest.peer +"&name="+ getMyName();       
                                        break;
                                    default:
                                        break;
                                }
                                // console.log("aim id of node: "+ guest.peer)  // DEBUG
                                break;
                            }
                        });
                        if(! ifConnectedAim){
                            guests.push(guest);
                        }
                    } else {
                        if(ifAskForMediaStream){
                            guest.on('open', () => {
                                guest.send([2, peer.id, getMyName()]);
                            });
                            
                            peer.on('call', (mediaOpenPort) => {
                                mediaOpen = mediaOpenPort;
                                // Receive the stream
                                mediaOpen.on('stream', (stream) => {
                                    localStream = stream;
                                    if( ! document.getElementById("ifNotDisplayLocalStream").checked){
                                        displayStream(stream);
                                    }
                                });
                                mediaOpen.answer(null);
                            });
                        } else {
                            guest.on('data', (data) => {
                                for(let i=0; i<guests.length; i++){
                                    if(guests[i].open){     // maybe useless
                                        guest = guests[i];
                                        guests = new Array();   // break all of conn
                                        nodesMap = data;
                                        ifConnectedAim = true;
                                        guest.on('data', () => {
                                            ifConnectedAim = false;
                                        });
                                        break;
                                    }
                                }
                            });
                            if(! ifConnectedAim){
                                guests.push(guest);
                            }
                        }
                    }
                    break;
                case 2:
                    if (bridge) {
                        bridge.close();
                    }
                    bridge = peer.connect(id);
                    alert("try to connect someone in rooms");
                case 3:
                    // Close old connection
                    if (root) {
                        root.close();
                    }

                    document.getElementById("status").innerHTML="Status: Connecting..."
                        
                    root = peer.connect(id);

                    root.on('open', () => {
                        root.send(nodesMap);
                        document.getElementById("status").innerHTML="Status: Connected to Root Node Successfully!"
                    });
                    
                    root.on('close', () => {
                        document.getElementById("status").innerHTML="Status: Root Connection Closed!"; 
                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="Status: Reconnecting to last Root Node...";
                            
                            tryConnect(0, urlInfo[0], false);
                        }
                    });
                    break;
                case 4:
                    // Close old connection
                    if (root) {
                        root.close();
                    }

                    root = peer.connect(id);
                    
                    root.on('open', () => {
                        document.getElementById('connectButton').innerHTML="Refresh";
                        document.getElementById('peerId').value=id;
                        document.getElementById("status").innerHTML="Status: Connected to Root Node Successfully!"
                    });

                    document.getElementById("peerId").addEventListener(
                        "focusout",
                        () => {
                            if (document.getElementById('peerId').value != id){
                                document.getElementById('connectButton').innerHTML="Connect";
                            }
                        },
                        true,
                    );

                    // Receive the reply of text: Host --> Guset
                    root.on('data', (data) => {
                        // data[0]:
                        //  0: msg
                        //  1: nodeInfo or indexRoomInfo 
                        //  2: roomInfoModfied
                        //
                        // Info of rooms from root received
                        appearRooms(data);
                        rooms = data;
                        console.log("Room list received");
                    });

                    root.on('close', () => {
                        // root = null;
                        document.getElementById("status").innerHTML="Status: Root Connection Closed!";
                        document.getElementById('connectButton').innerHTML="Connect";
                        
                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="Status: Reconnecting to last Root Node...";
                            
                            tryConnect(0, connectHistroy.slice(-1)[0], false);
                            // document.getElementById("status").innerHTML="Status: Root Reconnection Failed!";
                        }
                    });
                    break;
                default:
                    console.log("tryConnect Error");
                    break;
            }
        }

        function openRoomInfo() {       // top menu for showing the detail of room
            if(nodesMap[0] == undefined){
                alert("Error: void nodesMap");
                return;
            }
            if(openInfoTimes==0){
                    openInfoTimes++;
                    document.getElementById('openRoomInfo').style.height = "25%";
                    refreshMap(1);
            }else{
                openInfoTimes=0;
                document.getElementById('openRoomInfo').style.height = "0px";
            }
        }

        function streamSourceMenu(){
            if(document.getElementById('streamSource').style.height != "25%"){
                document.getElementById('streamSource').style.height = "25%";
            }else{
                document.getElementById('streamSource').style.height = "0px";
            } 
        }
        
        function displayNewPlayer(player){
            let newPlayer = document.createElement("div");
            newPlayer.classList.add('playersInfo');

            let newPlayerTag = document.createElement("span");
            // newPlayer.setAttribute("id", "playerTag" + String(player[0]));
            newPlayerTag.appendChild(document.createTextNode(String(player[0]) + ": "));
            newPlayerTag.classList.add('icon');
            newPlayer.appendChild(newPlayerTag);

            let newPlayerIcon = document.createElement("img");
            if(player[2]){
                newPlayerIcon.setAttribute("src", player[2]);
            } else {  // for different colour
                let colour = 255*((player[0] + 2)/(player[0] + 4));
                newPlayerIcon.setAttribute("style", "background-color: rgb("+parseInt(((((player[0]+1) % 5) + 1)/5)*colour)+", "+parseInt(((((player[0]+1) % 4) + 1)/4)*colour)+", "+parseInt(((((player[0]+1) % 3) + 1)/3)*colour)+")");
            }
            newPlayerIcon.classList.add('icon');
            newPlayer.appendChild(newPlayerIcon);

            if(player[5]){  // TODO
                let newPlayerCharacter = document.createElement("img");
                let character = null;
                switch (player[5]) {
                    case 1:
                        character = "";
                        break;
                    default:
                        character = "";
                        console.log("unknown character");
                        break;
                }
                newPlayerCharacter.setAttribute("src", character);
                newPlayerCharacter.classList.add('icon');
                newPlayer.appendChild(newPlayerCharacter);
            }

            let newPlayerName = document.createElement("span");
            newPlayerName.appendChild(document.createTextNode(player[3]));
            newPlayerName.setAttribute("style", "vertical-align: middle;");
            newPlayer.appendChild(newPlayerName);
            
            newPlayer.appendChild(document.createElement("br"));
            document.getElementById("playersList").appendChild(newPlayer);
        }

        function drawMap(){
            if(startTime){
                document.getElementById("canvasMap").innerHTML = "<div id=\"gameMap\"></div>";
                for(let t=1; t<=maxHeight*maxWidth; t++){
                    let cell = document.createElement("img");
                    cell.classList.add('cells');
                    cell.setAttribute("onclick", "applyForPut(this)");
                    cell.id = t;
                    let newLine = document.createElement("br");
                    document.getElementById("gameMap").appendChild(cell);
                    if(t%maxWidth==0){
                        document.getElementById("gameMap").appendChild(newLine);
                    }
                }
            } else {
                // document.getElementById("canvasMap").innerHTML = '\n        <br><br><br><br>\n        MapSize: Height:<input type="number" id="maxHeight" class="tidy" value="10"> Width:<input type="number" id="maxWidth" class="tidy" value="10"><br>\n        MaxPlayers: <input type="number" id="maxPlayers" class="tidy" value="2"><br>\n        GameMode: <select id="gameMode">\n            <option value="1" selected="selected">SLG Mode</option>\n            <option value="2">Energy Mode</option>\n            <option value="3">Card Mode</option>\n        </select><br>\n        HostJoinGame: <input type="checkbox" checked="true" id="hostJoinGame"><br>\n        <button id="start" onclick="start()">Start Game</button>\n    ';
            }
        }
        function effectFeedBack(position, type){
            return null;
        }

        function applyForPut(position){
            let positionId = Number(position.id);
            if(positionId && !(unavailablePosition.includes(positionId))){
                if(lastAimPosition !== position){
                    if(lastAimPosition){
                        lastAimPosition.classList.remove('inverted');
                    }
                    position.classList.add('inverted');
                    lastAimPosition = position;
                } else if(myNumber){
                    let now = new Date();
                    switch (gameInfo[3][0]) {
                        case 0:
                            if(turn === myNumber){
                                document.getElementById("myIcon").classList.remove("inverted");
                                if(parent){     // noticed: No circuit protection
                                    parent.send([7, 0, [1, positionId, myNumber, now.getTime()]]);
                                } else {
                                    liveSend([7, 1, [1, positionId, myNumber, now.getTime()]]);
                                    drawChessman([1, positionId, myNumber, now.getTime()]);
                                }
                            } else if (document.getElementById("predictive").checked){
                                positonDeliver = position;
                            } else {
                                alert("it is not your turn!(If you want, use predictive)");
                            }
                            break;
                        case 1:
                            if(energy() > 3){
                                leftEnergy - chessmanCode_1_Cost;
                                if(parent){
                                    parent.send([7, 0, [1, positionId, myNumber, now.getTime()]]);
                                } else {
                                    liveSend([7, 1, [1, positionId, myNumber, now.getTime()]]);
                                    drawChessman([1, positionId, myNumber, now.getTime()]);
                                }
                            } else if (document.getElementById("predictive").checked){
                                if(3 - leftEnergy < 1){
                                    setTimeout(applyForPut(position), (3 - leftEnergy)*1000);
                                    return;
                                }
                            }
                            break;
                        default:
                            console.log("unknown game mode")
                            break;
                    }
                }
            }
        }

        function drawChessman(chessman, effect){
            turn++;
            if (turn == myNumber) {
                document.getElementById("myIcon").classList.add("inverted");
            }
            switch (chessman[0]) {
                case 1:
                    if(turn >= players.length){
                        turn = 1;
                    }
                    document.getElementById("nowTurn").innerHTML = "Now Turn: "+turn+" ";
                    unavailablePosition.push(chessman[1]);
                    positionOwners.push(chessman[2]);

                    player = players[chessman[2]];
                    aimCell = document.getElementById(String(chessman[1]));
                    aimCell.classList.add("owner"+ player[0]);
                    if(player[2]){
                        aimCell.setAttribute("src", player[2]); // .innerHTML = "<img class=\"playerNumber"+ sourcePlayer[0] +"\" src=\"" + sourcePlayer[2] + ">";
                    } else {
                        // document.getElementById(String(chessman[1])).innerHTML = "<span class=\"playerNumber"+ sourcePlayer[0] +"\" >" + sourcePlayer[0] + "</span>";
                        let colour = 255*((player[0] + 2)/(player[0] + 4));
                        aimCell.setAttribute("style", "background-color: rgb("+parseInt(((((player[0]+1) % 5) + 1)/5)*colour)+", "+parseInt(((((player[0]+1) % 4) + 1)/4)*colour)+", "+parseInt(((((player[0]+1) % 3) + 1)/3)*colour)+")");
                    }
                    if (unavailablePosition.length === maxHeight*maxWidth) {
                        lastGameMap = gameMap;
                        // gameMap = null;
                        alert("No Winner!");   // style TODO
                        turn = null;
                        return;
                    }
                    [(-maxWidth)+1, 1, maxWidth+1, maxWidth].forEach(direction => {
                        let i = -4;
                        let t = 1;
                        while (i<5) {
                            if(i==0){i++;}
                            let aimPosition = chessman[1]+(i*direction);
                            // console.log(aimPosition);
                            if(unavailablePosition.includes(aimPosition) && positionOwners[unavailablePosition.indexOf(aimPosition)] == chessman[2]){
                                t++;
                                // console.log(chessman[2]+"th<------->"+aimPosition+"------------->"+t);
                                if (t>=5){        // 5 on line
                                    lastGameMap = gameMap;
                                    // gameMap = null;
                                    alert("Winner is "+ player[3]);   // style TODO
                                    turn = null;
                                    break;
                                }
                            } else if(5-i < 5-t){   // quit in advence
                                break;
                            } else {    // this position without the chessman of aim player
                                t = 1;
                            }
                            i++;
                        }
                    });
                    break;
            
                default:
                    console.log("drew unknown");
                    break;
            }
        }

        function reDraw(playerNumber) {
            let t = 0;
            while (t < positionOwners.length) {
                
            }
        }

        function energy() {
            if(!lastOperationTime){
                lastOperationTime = gameInfo[4];
            }
            let now = new Date();
            let t = (now.getTime() - lastOperationTime)/1000 + leftEnergy;
            if(t > maxEnergy){  // custome DEBUG
                leftEnergy = maxEnergy;
            } else {
                leftEnergy = t;
            }
            lastOperationTime = now.getTime();
            return leftEnergy;
        }

        // autoScroll the scrollbar
        document.getElementById("chatBox").addEventListener('onmouseover', ()=>{ ifAutoScroll = false;});
        document.getElementById("chatBox").addEventListener('onmouseout', ()=>{ ifAutoScroll = true;});

        // Listen for press enter in message box
        document.getElementById("sendMessageBox").addEventListener('keypress', enter);
        function enter(e) {
            let event = e && window.event;
            if (event.which && event.keyCode == '13'){
                document.getElementById("sendButton").click();
            }
        }
        
        MyName.addEventListener(
            "focusout",
            () => {
                if (MyName.value != hereNode[5] && MyName.value){
                    hereNode[5] = MyName.value;
                    parent.send(hereNode);
                }
            },
            true,
        );

        function recorder(data){    // todo :debug
            switch (data[1]){
                case 0:     // 0 means unfinished
                    let sameId = hereNode.indexOf(data[4]);   // locate old data
                    console.log('Info of nodes updated:', data);
                    // let idTemp = Object.assign({}, connPeers);     // make connIds value stable
                    if(sameId === -1){
                        hereNode.push(data[4]);
                        hereNode.push(data[5]);
                        hereNode.push(data);
                    } else {
                        hereNode[ sameId + 1 ] = data[5];
                        hereNode[ sameId + 2 ] = data;      // replace old data
                    }
                    // let idTemp = Object.assign({}, connIds);     // make connIds value stable
                    // idTemp[sameId] = data;      // replace old data
                    // hereMap = [1, peer.id, idTemp, null, 0];  //record this node's info
                    hereNode[2] = audienceIds.length;
                    if(parent){
                        if(parent.open){       // collect information about the connection map and send to parent node
                            if (audienceIds.includes(parent.peer)){    // fix connect mutually
                                for(let i=0; i<audiences.length; i++){  // send nodesMap to all of child nodes
                                    if(audiences[i] || audienceIds[i] == parent.peer){
                                        continue;
                                    }
                                    if(audiences[i].open){
                                        audiences[i].send([ 1, 1, audienceIds.length, [], null, null, null, peer.id, getMyName(), hereNode, null]);
                                    }
                                }
                            } else {
                                parent.send(hereNode);   // if not root node
                            }
                        }
                    }
                    break;
                case 1:    // once collection of data is completed            
                    for(let i=0; i<audiences.length; i++){     // send nodesMap to everyone
                        if(audiences[i]){
                            if(audiences[i].open){
                                audiences[i].send(data);
                            }
                        }
                    }
                    nodesMap = data;
                    document.getElementById("sumOfRoom").innerHTML = "Members: "+ nodesMap[2].length;
                    break;
                default:
                    console.log("unknown data" + data);
                    break;
            }
        }

        // destroy connection when someone closed the web
        window.addEventListener("beforeunload", (event) => {
            if(audiences[0]){
                for(let i=0; i<audiences.length; i++){
                    audiences[i].close();
                }
            }
            // event.preventDefault();
        });

    </script>
</body>
</html>