<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes" />
    <link rel="stylesheet" type="text/css" href="css/styleFiveOnline.css">
</head>
<body>
    <!-- Detail of Room -->
    <div id="openRoomInfo">
        <img id="roomCover">
        <div id="roomText">
            <div id="roomTitle"></div>
            <textarea id="roomSummary" rows="5" cols="32" readonly="readonly"></textarea>
            <div id="nodeInfo">
                <div id="stable">
                    <button id="hostBlock" onclick="echoNodesMap(nodesMap[9], 0, nodesMap[7], 1)">房主</button>
                    <button id="refreshMap" onclick="refreshMap(1)">刷新</button>
                </div>
                <div id="block0"></div>
                <div id="block1"></div>
            </div>
        </div>
        <div>
            <button id="autoJoin" class="actionButton" onclick="autoJoin(3)">自动<br>加入</button>
            <button id="closeInfo" class="actionButton" onclick="openRoomInfo()">关闭</button>
        </div>
    </div>
    <!-- Id interaction -->
    <div class="container">
        <div class="box">
            <!-- Sender -->
            <div style="font-weight: bold;">观众</div>
            <!-- Connect box -->
            <button id="refreshButton" onclick="refreshMedia()">刷新</button>
            <button id="openRoomInfoButton" onclick="openRoomInfo()">房间信息</button>
            <button onclick="peer.reconnect()">重连至Peer服务器</button>
            <div id="myid" style="font-weight: bold;">正在连接到Peer服务器...</div>
            <div id="status" style="font-weight: bold;">状态: 正在等待连接到Peer服务器...</div>
            <input type="checkbox" id="ifAutoReconnect" checked="checked">自动重连<br>
        </div>
        <div class="box">
            <button onclick="fullWebVideo()" id="fullScreen">铺满屏幕</button>
            <button onclick="hiddenAbility()" id="hiddenAbility">隐藏技能</button><br>
            <div>
                <img id="myIcon" style="width: 32px; height: 32px;"><div style="display: inline-block;">自定义头像与昵称<br/><input type="text" id="name" placeholder="填入你的名字..." /></div><br>
                <input type="file" name="icon" id="uploadIcon" onchange="iconInput()">
            </div>
        </div>
        <div class="box">
            <div id="playersList"></div>
            <span id="nowTurn">当前回合: 1 </span>
            <span id="sumOfRoom">成员数: 1</span>
            <span id="modeOutput">剩余时间: ∞</span><br>
            <input type="checkbox" id="ifAutoClean">自动清理信息[最大->100]<br>
            <button onclick="cleanMsg()">清理信息</button><br>
        </div>
    </div>
    
    <!-- Live interaction-->
    <div class="videoBox">
        <div id="canvasMap">
            <br><br>
            棋盘大小: 高<input type="number" id="maxHeight" class="setting" value="10" readonly> Width:<input type="number" id="maxWidth" class="setting" value="10" readonly><br>
            最大玩家数: <input type="number" id="maxPlayers" class="setting" value="5" readonly><br>
            游戏模式:<select id="gameMode" disabled>
                <option value="0" selected="selected">回合制</option>
                <option value="1">能量制</option>
            </select><br>
            房主加入游戏:<input type="checkbox" checked="true" class="setting" id="hostJoinGame" disabled><br>
            <div id="modeMenu">
            </div>
            <button id="join" onclick="parent.send([8, 0, peer.id, myIcon, getMyName(), myAbility])">准备</button>
        </div>
        <!-- Message box -->
        <div id="chatContainer">
            <div id="chatBox"></div>
            <div class="sendInput">
                <!-- Send box -->
                <input type="text" id="sendMessageBox" placeholder="填入你想发的信息..." autofocus="true" />
                <button type="button" id="uploadImgButton">图片</button>
                <button type="button" id="sendButton" onclick="sendMsg()">发送</button><br>
                <input id="msgImgInput" type="file" onchange="sendImg()" style="display: none;">
            </div>
        </div>
    </div>
    <script src="js/peerjs.min.js"></script>
    <!--script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script-->
    <script>
        const peer = new Peer({ debug: 2})      //use PeerJS official server
    </script>
    <script src="js/fn.js"></script>
    <script src="js/fiveOnlineFn.js"></script>
    <script>
        let urlId = params.get("id");
        let urlName = params.get("name");
        let hereNode = new Array();
        let changingParentConnection = false;
        let awaitedNodeId = null;
        let ifConnectedAim = false;
        
        // Listen for the event when a Peer connection is successfully opened
        // *Explanation: The provided code snippet is using the Peer.js library to establish a Peer connection. The peer.on('open', ...) code block is listening for the 'open' event, which is triggered when the Peer connection is successfully opened.
        peer.on('open', (id) => {
            MyName.value = urlName;
            hereNode = [ 1, 0, 0, [], id, getMyName(), []]
            console.log(id);
            document.getElementById("myid").innerHTML = "你的ID:<br/>" + id;
            document.getElementById("status").innerHTML="状态: 正在连接到房间...";
            tryConnect( 0, urlId, false);   // try to connect to the room
        });

        // When a new connection request is received, this code creates a data channel and sends the local or remote stream (if available) and text messages.
        peer.on('connection', (connPort) => {
            connIds.push(connPort.peer);
            conns.push(connPort);
            conn = connPort;

            conn.on('open', () => {
                // for guest in index
                let sendNodesMap = nodesMap;
                sendNodesMap[2] = -1;
                conn.send(sendNodesMap);
            });

            // Receive the text: Host <-- Parent
            conn.on('data', (data) => {
                // data[0]:
                //  0: msg
                //  1: nodeInfo or indexRoomInfo 
                //  2: roomInfoModfied
                //  3: for reconnect: Remind the child node to replace the parent node
                //  4: for refresh: apply to the new media Stream for daliver to child
                switch (data[0]) {
                    case 0:
                        console.log('Received data:', data);
                        deliverId = data[1];
                        data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                        
                        if ( liveSend(data) > 0 ) {
                            console.log("Msg delivered successfully: " + data);
                        }else{console.log('Msg delivered failed');}
                        
                        appearMsg(data);
                        break;
                    case 1:
                        if ( ! audienceIds.includes(data[4])){
                            let aimPosition = connIds.indexOf(data[4]);
                            audienceIds.push(connIds[aimPosition]);
                            audiences.push(conns[aimPosition]);

                            // for game:
                            conns[aimPosition].send(gameInfo);

                            console.log("Msg Connected to: " + data[4]);
                        }
                        recorder(data);
                        break;
                    default:
                        console.log("unknown data: " + data);
                }
            });

            
            conn.on('close', () => {
                for (let i = 0; i< conns.length; i++){
                    if(conns[i]){
                        if (conns[i].open){
                            continue;
                        }else{
                            let disconnectedGuest = connIds.indexOf(conns[i].peer);   // locate old data
                            if (disconnectedGuest !== -1){

                                let disconnectedAudience = audienceIds.indexOf(conns[i].peer);
                                if (disconnectedAudience !== -1){
                                    console.log("Disconnected and deleted: " + audienceIds[disconnectedAudience]);     //DEBUG
                                    audiences.splice(disconnectedAudience, 1);
                                    audienceIds.splice(disconnectedAudience, 1);
                                    
                                    let sameId = hereNode.indexOf(conns[i].peer);
                                    if(sameId !== -1){
                                        hereNode.splice(sameId, 3);     // remove disconnected audiences
                                        hereNode[2] = audienceIds.length;
                                    
                                        // one of child nodes closed the connection
                                        console.log("nodesMap update after somebody closed")    // DEBUG
                                        if (parent){
                                            if (parent.open){
                                                parent.send(hereNode);
                                            }
                                        }
                                    }
                                }
                                // console.log("Disconnected and deleted: " + conns[i].peer);     //DEBUG
                                conns.splice(disconnectedGuest, 1);
                                connIds.splice(disconnectedGuest, 1);
                            }
                        }
                    }else{break;}
                }
            });
            
        });

        peer.on('call', (mediaOpenPort) => {
            mediaOpen = mediaOpenPort;
            // Receive the stream
            mediaOpen.on('stream', (stream) => {
                remoteStream = stream;
                if(awaitedNodeId){
                    peer.call(awaitedNodeId, remoteStream/*document.getElementById('RemoteVideo').srcObject*/);
                    console.log("Media delivered successfully: "+ awaitedNodeId);
                    awaitedNodeId = null;
                } else {
                    displayStream(remoteStream);
                }
                console.log('Received stream:', stream);    // DEBUG
            });
            mediaOpen.answer(null);
        });

        function tryConnect(object, id, ifJump, ifAskForMediaStream){   // for fiveOnline Version
            // object:
            // 0: parent
            // 1: guest
            // 2: bridge
            // 3: root
            // 4: indexRoot
            switch (object) {
                case 0:
                    // Close old connection
                    if (parent) {
                        parent.close();
                        // [ mark of sorting, myId, number of who be effected, if keep parent firmly here ]
                        liveSend([3, peer.id, 0, false]);     // remind child node change parentNode
                    }
                    parent = peer.connect(id);

                    // Receive the reply of text: Host --> Guset
                    parent.on('data', (data) => {
                        // data[0]:
                        //  0: nodeInfo or indexRoomInfo 
                        //  1: msg
                        //  2: streaming request
                        //  3: for reconnect: Remind the child node to replace the parent node
                        //  4: for refresh: apply to the new media Stream for daliver to child

                        // fiveOnline:
                        // 6: gameInfo
                        // 7: chessman
                        // 8: player
                        switch (data[0]) {
                            case 0:
                                // console.log('Received data:', data); // DEBUG
                                deliverId = data[1];
                                data[1] = peer.id;  // make sure msg[2] keep last id of deliver
                                
                                if ( liveSend(data) > 0 ) {
                                    console.log("Msg delivered successfully: " + data);
                                }else{console.log('Msg delivered failed');}
                                
                                appearMsg(data);
                                break;
                            case 1:
                                if (data[1] == -1){ break; }    // refused to receive msg for guest
                                recorder(data);
                                break;
                            case 3:     // for single version
                                if(data[2] > 0 || data[3] == true){    // if it isn't the first node without correct parent node -> didn't auto changing the parent node
                                    RemoteVideo.src = null;
                                    remoteStream = null;
                                    mediaOpen.close();
                                    data[2]++;
                                    // optional setting
                                    // if(data[2]%5 == 0){
                                    //     autoJoin(nodesMap, 2, 0);
                                    // }
                                    liveSend(data);
                                    document.getElementById("status").innerHTML="Status: awaitng parent node autoReConnect to room( You can also ReConnect by yourself)!"
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    });
                                    break;
                                }
                                // changingParentConnection = true;
                                parent.close();
                                if(document.getElementById('ifAutoReconnect').checked){
                                    data[2]++;   // report child nodes await parent autoReConntect room
                                    liveSend(data);     
                                    // get the new nodeMap
                                    guest = peer.connect(nodesMap[7])
                                    guest.on('data', (data) => {
                                        nodesMap = data;
                                        autoJoin(3);
                                        guest.close();
                                    });
                                } else {
                                    data[3] = true;
                                    liveSend(data);
                                }
                                break;
                            case 6: // [6, [players[0]], gameMap, gameMode, startTime, unavailablePosition, positionOwners, modeSetting]
                                let i = 1;
                                if(data[4]){   // already started | Start Game
                                    startTime = data[4];
                                    players[0] = data[1][0];
                                    gameMap = data[2];
                                    mapSize = gameMap[0];
                                    maxHeight = mapSize[0];
                                    maxWidth = mapSize[1];
                                    gameMode = data[3];
                                    modeSetting = data[7];
                                    maxEnergy = modeSetting[1][0];
                                    modeModify(gameMode[0], modeSetting);
                                    if (data[1][1]) {  // firstly receive gameInfo
                                        let i = 1;
                                        gameInfo = data;
                                        players = gameInfo[1];
                                        while(i<players.length){
                                            displayNewPlayer(players[i]);
                                            i++;
                                        }
                                    }   // because of no sense of void player game, it is without dealing with new gameInfo which is hasn't any player
                                    drawMap();
                                    switch (gameMode[0]) {
                                        case 0:
                                            if (myNumber == 1) {
                                                document.getElementById("canvasMap").style.backgroundColor = 'rgb(80,83,80)';
                                            }
                                            if (modeSetting[0][0]) {
                                                waitingTime = maxWaitingTime;
                                                timer = setInterval(countDown, 1000);
                                            }
                                            break;
                                        case 1:
                                            setInterval(()=>{document.getElementById("modeOutput").innerHTML = "剩余能量: "+ (energy()*0.001).toFixed(3).slice(0, -2)}, 100);
                                            break;
                                        default:
                                            break;
                                    }
                                } else {    // update host setting
                                    if(startTime) {  // reset map( if === (startTime && !data[4]) )
                                        resetMap();
                                    }
                                    // console.log(data);  // DEBUG
                                    modeModify(data[3][0], data[7]);    // if different mode -> view bug
                                    document.getElementById("maxHeight").value = String(data[2][0][0]);
                                    document.getElementById("maxWidth").value = String(data[2][0][1]);
                                    document.getElementById("maxPlayers").value = String(data[1][0]);
                                    gameMode = [data[3][0], data[3][1]];
                                    document.getElementById("gameMode").selectedIndex = data[3][0];
                                    document.getElementById("hostJoinGame").checked = data[3][1];
                                    switch (data[3][0]) {
                                        case 0:
                                            if(data[7][0][0]){
                                                document.getElementById("ifCountDown").checked = true;
                                                document.getElementById("waitingTime").value = data[7][0];
                                            }
                                            break;
                                        case 1:
                                            document.getElementById("maxEnergy").value = data[7][1][0];
                                            document.getElementById("commonChessmanCost").value = data[7][1][1];
                                            break;
                                        default:
                                            break;
                                    }
                                    // document.getElementById("canvasMap").innerHTML = "<div id=\"canvasMap\" <br><br> MapSize: Height:"+ data[2][0][0] +" Width:"+ data[2][0][1] +"<br> MaxPlayers:"+ data[1][0] +" <br> GameMode:"+ data[3][0] +" <br> HostJoinGame:"+ data[3][1] +" <br> <button id=\"join\" onclick=\"parent.send([8, 0, peer.id, myIcon, getMyName()])\">Join Game</button> </div>"

                                    if (data[1][1]) {  // firstly receive gameInfo
                                        gameInfo = data;
                                        let i = 1;
                                        players = gameInfo[1];
                                        while(i<players.length){
                                            displayNewPlayer(players[i]);
                                            i++;
                                        }
                                    } else {
                                        let temp = gameInfo[1]; // keep old
                                        gameInfo = data;
                                        gameInfo[1] = temp;
                                    }
                                }
                                break;
                            case 7:
                                switch (data[1]) {
                                    case 0:
                                        parent.send(data);
                                        break;
                                    case 1:
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        gameMap.push(data[2]);
                                        drawChessman(data[2], data[3]);
                                        if(deliver && turn == myTurn){
                                            applyForPut(deliver);
                                        }
                                        break;
                                    default:
                                        console.log("unknown data: " + data);
                                        break;
                                }
                                break;
                            case 8:
                                switch (data[1]) {
                                    case 0:     // SB will join the game
                                        parent.send(data);
                                        break;
                                    case 1:
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        players.push(data[2]);
                                        if(data[2][1] == peer.id){
                                            myNumber = data[2][0];
                                            if(document.getElementById("join")){
                                                document.getElementById("join").innerHTML = "取消准备";
                                            }
                                            if (gameMode[0] == 1) {
                                                Array.from(document.getElementsByClassName("abilities")).forEach(abilityNode => {
                                                    abilityNode.classList.add("gray");
                                                });
                                            }
                                            ready = true;
                                        }
                                        displayNewPlayer(data[2]);
                                        break;
                                    case 2:     // kick SB
                                        deliverId = parent.peer;
                                        liveSend(data);
                                        if(data[2] == myNumber){
                                            myNumber = null;
                                            if(document.getElementById("join")){
                                                document.getElementById("join").innerHTML = "Join Game";
                                            }
                                            document.getElementById("canvasMap").style.backgroundColor = 'rgb(28, 33, 40)';

                                            if (gameMode[0] == 1 && !startTime) {
                                                Array.from(document.getElementsByClassName("abilities")).forEach(abilityNode => {
                                                    abilityNode.classList.remove("gray");
                                                });
                                            }
                                            ready = false;
                                        }
                                        if (startTime) {
                                            kickNumbers.push(data[2]);
                                            document.getElementsByClassName("playersInfo")[data[2]-1].childNodes[2].innerHTML = document.getElementsByClassName("playersInfo")[data[2]-1].childNodes[2].innerHTML + "(kicked)";
                                            appearMsg([ 0, null, "系统", "玩家: "+ players[data[2]][3]+" 被踢出游戏"]);
                                        } else {    // remove player & adjust players who behind the removed player
                                            let i = 1;
                                            let position = false;
                                            while(i<players.length){
                                                if(players[i] instanceof Array){
                                                    if(position){
                                                        players[i][0]--;
                                                        document.getElementsByClassName("playersInfo")[i-1].children[0].innerHTML = i+": ";
                                                        if(!players[i][2]){      // kick and change default color
                                                            player = players[i];
                                                            let colour = 255*((player[0] + 2)/(player[0] + 4));
                                                            document.getElementsByClassName("playersInfo")[i-1].children[1].setAttribute("style", "background-color: rgb("+parseInt(((((player[0]+1) % 5) + 1)/5)*colour)+", "+parseInt(((((player[0]+1) % 4) + 1)/4)*colour)+", "+parseInt(((((player[0]+1) % 3) + 1)/3)*colour)+")");
                                                        }
                                                    }
                                                    if(players[i][0] == data[2] && (!position)){   // refer to number
                                                        players.splice(i, 1);
                                                        document.getElementsByClassName("playersInfo")[i-1].remove();
                                                        position = i;   // changed
                                                    } else {
                                                        i++;
                                                    }
                                                } else {i++;}
                                            }
                                        }
                                        if (turn == data[2] && startTime && (gameMode[0] == 0)) {
                                            nextTurn();
                                        }
                                        // if(position){
                                        //     if(position < myNumber){
                                        //         myNumber--;
                                        //     }
                                        // }
                                        // if(turn >= players.length){
                                        //     trun = 1;
                                        //     document.getElementById("nowTurn").innerHTML = "Now Turn: "+turn+" ";
                                        // }
                                        // if(data[3] == peer.id){
                                        //     peer.distory();
                                        // } else if (audienceIds.includes(data[3])){
                                        //     audiences[audienceIds.indexOf(data[3])].close();
                                        // }
                                        break;
                                    case 3: // SB quit in gameing
                                        // TODO
                                    default:
                                        console.log("unknown data: " + data);
                                        break;
                                }
                                break;
                            default:
                                console.log("unknown data: " + data);
                        }
                    });

                    parent.on('open', () => {
                        // changingParentConnection = false;
                        parent.send(hereNode);
                        document.getElementById("status").innerHTML="状态: 成功连接到房间."
                        appearMsg([ 0, null, "系统", "连接成功"]);
                    });
                    
                    // parent.on('error', (err) => {
                    //     document.getElementById("status").innerHTML="Status: Connecting Failed!" + err;
                    // });

                    parent.on('close', () => {
                        document.getElementById("status").innerHTML="状态: 与房间建立的连接断开，请尝试刷新!"

                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="状态: 正在尝试重新连接到房间...";
                            
                            autoJoin(3);
                            
                        }
                    });
                    break;
                    
                case 1:
                    if(guest){if(guest.open){
                        guest.close();
                    }}
                    guest = peer.connect(id);
                    
                    if(ifJump){
                        guest.on('open', () => {
                            for(let i=0; i<guests.length; i++){
                                guest = guests[i];
                                guests = new Array();   // break all of conn
                                ifConnectedAim = true;
                                switch (gameInfo[0]) {
                                    case 0:
                                        document.location.href = "./P2PLiveAudience.html?id="+ guest.peer +"&name="+ getMyName();       
                                        break;
                                    case 1:
                                        document.location.href = "./P2PGameFiveOnLinePlayer.html?id="+ guest.peer +"&name="+ getMyName();       
                                        break;
                                    default:
                                        break;
                                }
                                // console.log("aim id of node: "+ guest.peer)  // DEBUG
                                break;
                            }
                        });
                        if(! ifConnectedAim){
                            guests.push(guest);
                        }
                    } else {
                        if(ifAskForMediaStream){
                            guest.on('open', () => {
                                guest.send([2, peer.id, getMyName()]);
                            });
                            
                            peer.on('call', (mediaOpenPort) => {
                                mediaOpen = mediaOpenPort;
                                // Receive the stream
                                mediaOpen.on('stream', (stream) => {
                                    localStream = stream;
                                    if( ! document.getElementById("ifNotDisplayLocalStream").checked){
                                        displayStream(stream);
                                    }
                                });
                                mediaOpen.answer(null);
                            });
                        } else {
                            guest.on('data', (data) => {
                                for(let i=0; i<guests.length; i++){
                                    if(guests[i].open){     // maybe useless
                                        guest = guests[i];
                                        guests = new Array();   // break all of conn
                                        nodesMap = data;
                                        ifConnectedAim = true;
                                        guest.on('data', () => {
                                            ifConnectedAim = false;
                                        });
                                        break;
                                    }
                                }
                            });
                            if(! ifConnectedAim){
                                guests.push(guest);
                            }
                        }
                    }
                    break;
                case 2:
                    if (bridge) {
                        bridge.close();
                    }
                    bridge = peer.connect(id);
                    alert("try to connect someone in rooms");
                case 3:
                    // Close old connection
                    if (root) {
                        root.close();
                    }

                    document.getElementById("status").innerHTML="状态: 正在连接..."
                        
                    root = peer.connect(id);

                    root.on('open', () => {
                        root.send(nodesMap);
                        document.getElementById("status").innerHTML="状态: 成功连接到根节点"
                    });
                    
                    root.on('close', () => {
                        document.getElementById("status").innerHTML="状态: 与根节点建立的连接断开!"; 
                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="状态: 正在尝试重新连接到上个根节点";
                            
                            tryConnect(0, urlInfo[0], false);
                        }
                    });
                    break;
                case 4:
                    // Close old connection
                    if (root) {
                        root.close();
                    }

                    root = peer.connect(id);
                    
                    root.on('open', () => {
                        document.getElementById('peerId').value=id;
                        document.getElementById("status").innerHTML="状态: 成功连接到根节点!"
                    });

                    // document.getElementById("peerId").addEventListener(
                    //     "focusout",
                    //     () => {
                    //         if (document.getElementById('peerId').value != id){
                    //             document.getElementById('connectButton').innerHTML="Connect";
                    //         }
                    //     },
                    //     true,
                    // );

                    // Receive the reply of text: Host --> Guset
                    root.on('data', (data) => {
                        // data[0]:
                        //  0: msg
                        //  1: nodeInfo or indexRoomInfo 
                        //  2: roomInfoModfied
                        //
                        // Info of rooms from root received
                        appearRooms(data);
                        rooms = data;
                        console.log("Room list received");
                    });

                    root.on('close', () => {
                        // root = null;
                        document.getElementById("status").innerHTML="状态: 与根节点建立的连接断开!";
                        
                        if(document.getElementById("ifAutoReconnect").checked){
                            document.getElementById("status").innerHTML="状态: 正在尝试重新连接到上个根节点...";
                            
                            tryConnect(0, connectHistroy.slice(-1)[0], false);
                            // document.getElementById("status").innerHTML="Status: Root Reconnection Failed!";
                        }
                    });
                    break;
                default:
                    console.log("tryConnect Error");
                    break;
            }
        }

        function openRoomInfo() {       // top menu for showing the detail of room
            if(nodesMap[0] == undefined){
                alert("Error: void nodesMap");
                return;
            }
            if(openInfoTimes==0){
                    openInfoTimes++;
                    document.getElementById('openRoomInfo').style.height = "25%";
                    refreshMap(1);
            }else{
                openInfoTimes=0;
                document.getElementById('openRoomInfo').style.height = "0px";
            }
        }

        function modeModify(mode, modeSetting) {
            switch (mode) {
                case 0: //  modeSetting: [maxWaitingTime]
                    maxWaitingTime = modeSetting[0][0];
                    document.getElementById("modeMenu").innerHTML = '最大等待时间(启用与否 & 时间设置): <input type="checkbox" id="ifCountDown" disabled><input type="number" id="waitingTime" class="setting" value="60" min="1" readonly><br>';
                    break;
                case 1: //  modeSetting: [ maxEnergy, chessmanCode_1_Cost, chessmanCode_2_Cost, chessmanCode_3_Cost ]
                    document.getElementById("modeMenu").innerHTML = '选择你的技能: ';
                    document.getElementById("modeOutput").innerHTML ="剩余能量: 0";
                    abilitiesURLS.slice(1).forEach(abilitiesURL => {
                        let ability = document.createElement("img");
                        ability.setAttribute('src', abilitiesURL);
                        ability.setAttribute('onclick', "chooseAbility("+ abilitiesURLS.indexOf(abilitiesURL) +")");
                        ability.classList.add('cells');
                        ability.classList.add('abilities');
                        document.getElementById("modeMenu").appendChild(ability);
                    });
                    document.getElementById("modeMenu").appendChild(document.createElement("br"));
                    let input = document.createElement("input");
                    input.setAttribute('type', "number");
                    input.classList.add('mode2Setting');
                    input.setAttribute('readonly', 'true');

                    let input1 = input.cloneNode();
                    input1.id = "commonChessmanCost";
                    input1.setAttribute('value', modeSetting[1][1]);
                    document.getElementById("modeMenu").appendChild(document.createTextNode("普通棋子能量开销: "));
                    document.getElementById("modeMenu").appendChild(input1);
                    document.getElementById("modeMenu").appendChild(document.createElement("br"));

                    let input2 = input.cloneNode();
                    input2.id = "maxEnergy";
                    input2.setAttribute('value', modeSetting[1][0]);
                    document.getElementById("modeMenu").appendChild(document.createTextNode("最大能量上限: "));
                    document.getElementById("modeMenu").appendChild(input2);
                    document.getElementById("modeMenu").appendChild(document.createElement("br"));

                    input.remove();
                    break;
                default:
                    break;
            }
        }
        
        function displayNewPlayer(player){
            let newPlayer = document.createElement("div");
            newPlayer.classList.add('playersInfo');

            let newPlayerTag = document.createElement("span");
            // newPlayer.setAttribute("id", "playerTag" + String(player[0]));
            newPlayerTag.appendChild(document.createTextNode(String(player[0]) + ": "));
            newPlayerTag.classList.add('icon');
            newPlayer.appendChild(newPlayerTag);

            let newPlayerIcon = document.createElement("img");
            if(player[2]){
                newPlayerIcon.setAttribute("src", player[2]);
            } else {  // for different colour
                let colour = 255*((player[0] + 2)/(player[0] + 4));
                newPlayerIcon.setAttribute("style", "background-color: rgb("+parseInt(((((player[0]+1) % 5) + 1)/5)*colour)+", "+parseInt(((((player[0]+1) % 4) + 1)/4)*colour)+", "+parseInt(((((player[0]+1) % 3) + 1)/3)*colour)+")");
            }
            newPlayerIcon.classList.add('icon');
            newPlayer.appendChild(newPlayerIcon);

            if(gameMode[0] == 1){
                let newPlayerAbility = document.createElement("img");
                if (player[4]) {
                    newPlayerAbility.setAttribute("src", abilitiesURLS[player[4]]);
                } else {
                    newPlayerAbility.setAttribute("src", abilitiesURLS[1]);
                }
                newPlayerAbility.classList.add('icon');
                newPlayer.appendChild(newPlayerAbility);
            }

            let newPlayerName = document.createElement("span");
            newPlayerName.appendChild(document.createTextNode(player[3]));
            newPlayerName.setAttribute("style", "vertical-align: middle;");
            newPlayer.appendChild(newPlayerName);
            
            newPlayer.appendChild(document.createElement("br"));
            document.getElementById("playersList").appendChild(newPlayer);
        }
        
        function effectFeedBack(position, type){
            return null;
        }
        
        MyName.addEventListener(
            "focusout",
            () => {
                if (MyName.value != hereNode[5] && MyName.value){
                    hereNode[5] = MyName.value;
                    parent.send(hereNode);
                }
            },
            true,
        );

        function recorder(data){    // todo :debug
            switch (data[1]){
                case 0:     // 0 means unfinished
                    let sameId = hereNode.indexOf(data[4]);   // locate old data
                    console.log('Info of nodes updated:', data);
                    // let idTemp = Object.assign({}, connPeers);     // make connIds value stable
                    if(sameId === -1){
                        hereNode.push(data[4]);
                        hereNode.push(data[5]);
                        hereNode.push(data);
                    } else {
                        hereNode[ sameId + 1 ] = data[5];
                        hereNode[ sameId + 2 ] = data;      // replace old data
                    }
                    // let idTemp = Object.assign({}, connIds);     // make connIds value stable
                    // idTemp[sameId] = data;      // replace old data
                    // hereMap = [1, peer.id, idTemp, null, 0];  //record this node's info
                    hereNode[2] = audienceIds.length;
                    if(parent){
                        if(parent.open){       // collect information about the connection map and send to parent node
                            if (audienceIds.includes(parent.peer)){    // fix connect mutually
                                for(let i=0; i<audiences.length; i++){  // send nodesMap to all of child nodes
                                    if(audiences[i] || audienceIds[i] == parent.peer){
                                        continue;
                                    }
                                    if(audiences[i].open){
                                        audiences[i].send([ 1, 1, audienceIds.length, [], null, null, null, peer.id, getMyName(), hereNode, null]);
                                    }
                                }
                            } else {
                                parent.send(hereNode);   // if not root node
                            }
                        }
                    }
                    break;
                case 1:    // once collection of data is completed            
                    for(let i=0; i<audiences.length; i++){     // send nodesMap to everyone
                        if(audiences[i]){
                            if(audiences[i].open){
                                audiences[i].send(data);
                            }
                        }
                    }
                    nodesMap = data;
                    document.getElementById("sumOfRoom").innerHTML = "成员数: "+ nodesMap[2].length;
                    break;
                default:
                    console.log("unknown data" + data);
                    break;
            }
        }

        // destroy connection when someone closed the web
        window.addEventListener("beforeunload", (event) => {
            if(audiences[0]){
                for(let i=0; i<audiences.length; i++){
                    audiences[i].close();
                }
            }
            // event.preventDefault();
        });
    if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
        document.getElementById("playersList").style.maxHeight = '200px';
    }
    </script>
</body>
</html>
